# GC

## OverView

- *Garbage Collection* (垃圾收集) ，是用来将被称为的  **Garbage** 的对象，进行标记和清理的过程。
- （这是java 这一类内存自动管理语言的必备能力）。他简化了C/C++ 程序语言中需要手动申请内存，释放内存等操作。
- 将这一块功能纳入到 JVM  的管理之中。这也是性能不如C/C++ 的原因之一。所以jvm 对gc的效率要求高，且不能影响用户线程

## GC分代依据

- 基于统计学概率。90%对象朝生夕死。所以为了充分利用这一特性。提高垃圾收集的效率。GC基本都是采用分代体系进行垃圾收集。
- ***\*GC分代的基本假设：\*******\*绝大部分对象的生命周期都非常短暂，存活时间短。\****
- “分代收集”（Generational Collection）算法，把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。
- **在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集**。
- **而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记-清理”或“标记-整理”算法来进行回收。**



## 什么是垃圾

- 判断一个是否为垃圾主要有几种方式：
  - 引用计数
  - 可达性分析：GC ROOT 能否搜索到该对象
    - GC ROOT （各种引用地）
      - 虚拟机栈中引用的对象
      - 静态对象引用
      - 方法区中常量引用
      - 本地方法栈中的引用



## 垃圾收集算法

- https://www.cnblogs.com/ityouknow/p/5614961.html

- 复制
- 标记清楚
- 标记清理

## GC收集器

- https://www.cnblogs.com/ityouknow/p/5614961.html
- 串行新生代 老年代
  - Serial收集器
- 并行新生代 老年代
  - ParNew收集器
  - Parallel收集器
  - Parallel Old 收集器
- CMS 低停顿
  - 低延迟
  - 回收效率低
  - FULL GC 需要 Parallel
- G1（垃圾优先）
  - 不要求分配连续
  - 可预测的停顿
    - 优化标记手段
    - 达到阈值回收特定算法针对回收比例高

