## 逃逸分析

### 什么是逃逸分析

- 逃逸分析是指jvm优化的一种分析指标。它不是直接的优化手动，而是为优化提供依据。
- 逃逸分析主要由两种是方法逃逸 （对象逃逸）、线程逃逸
  - 方法逃逸
    - 方法里创建对象，调用其他方法传入該对象作为参数。
    - 全局静态变量
  - 线程逃逸
    - 当被其他线程访问，如赋值给其他线程中的实例变量，则成为**线程逃逸**。

### 逃逸分析优化手段

- 针对线程逃逸

  - 可以进行锁消除优化

    - ### 锁消除

      我们知道线程同步锁是非常牺牲性能的，当编译器确定当前对象只有当前线程使用，那么就会移除该对象的同步锁。

      例如，StringBuffer 和 Vector 都是用 synchronized 修饰线程安全的，但大部分情况下，它们都只是在当前线程中用到，这样编译器就会优化移除掉这些锁操作。

      **锁消除的 JVM 参数如下**：

      - 开启锁消除：-XX:+EliminateLocks
      - 关闭锁消除：-XX:-EliminateLocks

      锁消除在 JDK8 中都是默认开启的，并且锁消除都要建立在逃逸分析的基础上。

- 方法逃逸

  - 可以使用标量替换，使用栈创建对象，而不使用堆。

    （当对象没有发生逃逸时，该对象就可以通过标量替换分解成成员标量分配在栈内存中，和方法的生命周期一致，随着栈帧出栈时销毁，减少了 GC 压力，提高了应用程序性能。）

    - 首先要明白标量和聚合量，基础类型和对象的引用可以理解为标量，它们不能被进一步分解。而能被进一步分解的量就是聚合量，比如：对象。

      对象是聚合量，它又可以被进一步分解成标量，将其成员变量分解为分散的变量，这就叫做标量替换。

      这样，如果一个对象没有发生逃逸，那压根就不用创建它，只会在栈或者寄存器上创建它用到的成员标量，节省了内存空间，也提升了应用程序性能。

      **标量替换的 JVM 参数如下**：

      - 开启标量替换：-XX:+EliminateAllocations
      - 关闭标量替换：-XX:-EliminateAllocations
      - 显示标量替换详情：-XX:+PrintEliminateAllocations

      标量替换同样在 JDK8 中都是默认开启的，并且都要建立在逃逸分析的基础上。

### 相关问题解答

- 对象是否一定在栈上分配
- 锁的升级过程。

